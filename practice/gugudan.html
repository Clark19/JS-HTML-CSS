<!-- 출처: 책 'Do it! HTML+CSS+자바스크립트 웹 표준의 정석' -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>자바스크립트로 구구단 만들기</title>

  <style>
    /* body{display: flex;} */
    div {
      display: inline-block;
      padding: 0 20px 30px 20px;
      margin: 5px;
      border: 1px solid #ccc;
      line-height: 2;
    }

    div h3 {
      text-align: center;
      font-weight: bold;
    }

    table,
    td {
      border: 1px solid #777;
      border-collapse: collapse;
    }

    td {
      padding: 5px;
      font-size: 0.9em;
      text-align: center;
    }

    /* ToDo */
    .check {
      color: #ccc;
      font-size: 20px;
      margin-right: 25px;
    }

    .checked {
      text-decoration: line-through;
      color: #ccc;
    }

    .btn {
      margin-left: 10px;
    }

    #todo li input {
      border: none;
    }
  </style>
</head>

<body>
  <h1>JavaScript 연습 - 출처: 책 'Do it! HTML+CSS+자바스크립트 웹 표준의 정석'</h1>

  <section id="btns">
    <h2>배경 색상 변경 버튼</h2>
    <ul>
      <li>Green</li>
      <li>Orange</li>
      <li>Purple</li>
    </ul>
    <style>
      ul {
        list-style: nonoe;
      }

      ul li {
        display: inline-block;
        border: 1px solid #777;
        border-radius: 7px;
        padding: 7px;
      }

      ul li:hover {
        cursor: pointer;
      }

      /* ul li:active { } */
    </style>
  </section>

  <!-- (레이어드)팝업창 연습  -->
  <section id="currentTime">
    <p>현재 시각 <span id="current" class="display"></span></p>
    <button id="btn_time">현재시각 팝업창</button>
    <section id='timePopSection'>
      <h3></h3>
      <button id='btn_closeTime'>닫기</button>
    </section>
    <style>
      #currentTime p {
        margin-top: 20px;
        font-size: 1.2em;
        text-align: center;
      }

      #currentTime .display {
        font-size: 1.5em;
        font-weight: bold;
        color: blue;
      }

      #timePopSection {
        display: none;
        position: absolute;
        z-index: 5;
        border: 1px solid #777;
        background: #777;
      }
    </style>
  </section>

  <!-- ToDo 입력 -->
  <section id="todo">
    <form action="">
      <input type="text" id="input_todoText" autofocus placeholder="할 일을 입력하세요">
      <button id='btn_addTodo'>추가</button>
    </form>
    <ul id='todoList'>
    </ul>
  </section>

  <!-- 동적 테이블 만들기 -->
  <section id="section_makeTable">
    <section id="inputTableSection">
      <input type="text" id="rows" size='5'>행
      <input type="text" id="cols" size='5'>열
      <button id="btn_makeTable">표 생성</button>
    </section>
    <!-- <table>
    </table> -->
  </section>

  <h2>구구단 - Ch.14</h2>

  <div id="bookdate">
    <h1>책 읽기</h1>
    <p><span class="accent" id="result"></span>일 연속으로 <br> 책 읽기를 달성했군요.</p>
    <p>축하합니다!</p>
    <style>
      #bookdate {
        margin: 50px auto;
        width: 300px;
        height: 300px;
        border-radius: 50%;
        border: 2px double #222;
        background-color: #d8f0fc;
        text-align: center;
        transition: .5s;
      }

      h1 {
        margin-top: 80px;
      }

      .accent {
        font-size: 1.8em;
        font-weight: bold;
        color: red;
      }
    </style>
  </div>

  <button onclick="location.assign(' http://www.easyspub.co.kr/20_Menu/BookView/228/EDU')">이지스퍼블리싱 홈페이지로 이동</button>
  <!-- location.replace()사용하면 뒤로가기가 안되서 불편 함. -->

  <button id='btn_newNode'>새로운 노드 추가</button>

  <section id="section_imgChange">
    <div id="prod-pic">
      <img src="images/coffee-pink.jpg" alt="커피 사진" id='cup' width="200" height='200'>
      <!-- onclick='displaySrc()'> -->
      <div id="small-pic">
        <img src="images/coffee-pink.jpg" alt="" class="small">
        <img src="images/coffee-blue.jpg" alt="" class="small">
        <img src="images/coffee-gray.jpg" alt="" class="small">
      </div>
    </div>

    <!-- 이미지 라이트 박스 - 레이어드 팝업과 유사 -->
    <div class="row">
      <h2>이미지 라이트 박스</h2>
      <ul>
        <li><img src="images/tree-3-thumb.jpg" data-src="images/tree-3.jpg" class="pic"></li>
        <li><img src="images/tree-4-thumb.jpg" data-src="images/tree-4.jpg" class="pic"></li>
        <li><img src="images/tree-6-thumb.jpg" data-src="images/tree-6.jpg" class="pic"></li>
      </ul>
    </div>
    <div id="lightbox">
      <img src="images/coffee-pink.jpg" alt="" id='lightboxImage'>
    </div>
    <style>
      /* 라이트 박스 스타일 */
      #lightbox {
        position: fixed;
        /* 위치 고정 */
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, .7);
        top: 0;
        left: 0;
        display: none;
      }

      /* 라이트 박스 안의 이미지 */
      #lightbox img {
        position: absolute;
        /* top, left에 의한 위치 지정 */
        top: 50%;
        /*  top/left에서 50% 수치는 페이지 크기의 50%인듯 */
        left: 50%;
        transform: translate(-50%, -50%);
        /* 요소를 화면 중앙에 표시하기 위해 이동: -50% 수치는 img 엘리먼트 자체 크기에서 50%인듯 */
        border: 5px solid #eee;
      }
    </style>
  </section>


  <script>
    // 구구단
    for (let i = 2; i <= 9; i++) {
      document.write("<div>");
      document.write("<h3>" + i + "단</h3>");
      for (let j = 1; j <= 9; j++) {
        document.write(`${i} x ${j} = ${i*j}<br>`);
      }
      document.write("</div>");
    }

    const userNum = 5;
    let n = userNum;
    let sum = 1;
    while (n) {
      sum *= n--;
    }
    console.log(`${n}! = ${sum}`);
    document.write('<br><br>');


    document.write('<h2>좌석 번호 매기기</h2>');
    let memNum = 41; //parseInt(prompt('입장객은 몇 명인가요?', 41));
    let colNum = 7; //parseInt(prompt('한 줄에 몇 명씩 앉습니까?', 7));
    let rowNum = 1;
    if (memNum % colNum === 0)
      rowNum = parseInt(memNum / colNum);
    else
      rowNum = parseInt(memNum / colNum) + 1;
    let seatNo = 0;
    document.write(`<table>`)
    for (let i = 0; i < rowNum; i++) {
      document.write(`<tr>`)
      for (let j = 1; j <= colNum; j++) {
        seatNo = i * colNum + j;
        if (seatNo > memNum) break;
        document.write(`<td>좌석${seatNo}</td>`)
      }
      document.write('</tr>');
    }
    document.write(`</table>`)

    // 호이스팅 예제 (hoisting : 끌어올린다라는 뜻) - 실제 소스 코드를 끌어올린다는 것이 아니고 그런 식으로 해석한다는 의미
    let x = 10

    function fn1() {
      console.log('x=' + x)
      console.log(y)
      var y = 20; // 호이스팅이 일어나는 문
    }
    fn1();


    document.querySelectorAll('ul li').forEach(item => {
      item.onclick = function () {
        document.body.style.backgroundColor = this.innerHTML.toLowerCase();
      }
      item.onmouseover = function () {
        this.style.backgroundColor = this.innerHTML.toLowerCase();
      }
      item.onmouseleave = function () {
        this.style.backgroundColor = 'inherit';
      }
    });


    // 15장 마무리 문제 1번
    const n1 = 5; //parseInt(prompt('number? : ', 5))
    const n2 = 10; //parseInt(prompt('number? : ', 10))
    function sumMulti(n1, n2) {
      return n1 === n2 ? n1 * n2 : n1 + n2; // 조건 연산자 == 삼항연산자
    }
    console.log(sumMulti(n1, n2));

    // Array 객체의 메서드
    let nums = [1, 2, 3]
    let chars = ['a', 'b', 'c', 'd']
    // concat() : immutable. concat()으로 합쳐진 배열은 기존 배열에 영향을 주지 않고 새로운 배열을 만든다.
    const numsChars = nums.concat(chars)
    const charsNums = chars.concat(nums)
    console.log(numsChars, charsNums)
    console.log(numsChars.join('/'))

    console.log('before: ' + nums)
    // unshift(), push() 하면 원래 배열이 바뀌다고 함. mutable
    nums.unshift(-1, 0); // 맨앞에 넣음
    let ret1 = nums.push(4, 5); // 맨뒤에 넣음
    console.log('after nums : ' + nums)
    console.log(ret1)

    // shift():맨앞에서 뺌, pop():맨뒤에서 뺌. mutable
    nums.shift()
    console.log('shift() : ' + nums)
    nums.pop()
    console.log('pop() : ' + nums)

    // splice(): mutable. 중간 원하는 지점에 원하는 만큼 빼내 반환, 그자리에 새 요소들 추가도 가능. 원형 인스턴스 변경됨.
    let study = ['html', "css", 'web', 'jquery']
    console.log(`study: [${study.join()}]`)
    let newStudy = study.splice(2, 1)
    console.log(`.splice(2,1) => study: [${study.join(',')}] => newStudy: ${newStudy}`)
    study.splice(2, 1, 'js')
    console.log(`.splice(2,1,'js') => study: [${study.join()}]`)

    // slice(): immutable. 원하는 지점의 원소를 빼내지만, 원형 인스턴스는 변경 안됨.
    let colors = ['red', 'green', 'blue', 'white', 'black']
    console.log(`colors: [${colors.join()}]`)
    let colors2 = colors.slice(2, 4)
    console.log(`colors: [${colors.join()}]`)
    console.log(`colors2: [${colors2.join()}]`)


    // 날짜경과/시간차 계산
    let today = new Date()
    let startDay = new Date('2021-08-11T00:00:00')
    let passedTime = today.getTime() - startDay.getTime();
    let days = Math.ceil(passedTime / (1000 * 60 * 60 * 24))
    console.log('passedTime: ' + passedTime)
    console.log('days: ' + days)
    document.querySelector('#result').innerHTML = days;
    document.getElementById('bookdate').onmouseover = function () {
      this.style.borderRadius = '10px';
      this.style.backgroundColor = "green";
    }
    document.getElementById('bookdate').onmouseout = function () {
      this.style.borderRadius = ''; //테두리 원래 값으로 지정
      this.style.backgroundColor = ''; //원래 값으로 지정

    }


    // 당첨자 뽑기 : 100명중 랜덤 숫자 뽑기 = 1 ~ 100번
    const numOfPerson = 100;
    let pickNum = Math.floor(Math.random() * numOfPerson + 1); // 반올림이나 올림하면 100번이 넘어갈 수 있으므로 floor으로 소수점 버림
    console.log(`Winner Number is ${pickNum}`)

    // 팝업 차단 체크와 팝업 창 생성/열기
    function openPopup(doc, popName, w, h) {
      // !주의: 팝업 윈도우 네임 지정하지 않으면 새로고침시 팝업창이 계속 중복해서 생성됨.
      // 팝업창을 화면 한 가운데 표시하기 [[
      const left = (screen.availWidth - w) / 2;
      const top = (screen.availHeight - h) / 2;
      // window.screenX, screenY 는 전체 화면에서 브라우져의 left, top 좌표임
      let opt = `width=400, height=400, left=${left}, top=${top}`;
      // ]]
      let newPopup = window.open(doc, popName, opt)
      //팝업 창에서 부모로 접근하기 위해, 팝업창 객체를 만든 부모가 자신(self)이라고 알려 줌.
      newPopup.creator = self;
      newPopup ? newPopup.moveBy(50, 50) : alert('팝업 차단됨. 차단 해제 바람')
    }
    // 문서 열리자 마자 팝업창 열림.
    openPopup('practice.html', 'Popup Window Name', 400, 500);

    function locationTest() {
      document.write("<p><b>location.href : </b>" + location.href + "</p>")
      document.write("<p><b>location.host : </b>" + location.host + "</p>")
      document.write("<p><b>location.protocol : </b>" + location.protocol + "</p>")
    };
    locationTest();

    // 현재 시각 페이지에 출력하기
    setInterval(displayTime, 1000); // 1초마다 시간 계산 함수 실행
    function displayTime() {
      const date = new Date();
      const time = date.toLocaleTimeString(); //  toLocaleTimeString() 메서드를 사용해 지역에 맞는 시간을 가져옴
      document.querySelector('#current').innerHTML = time;
    }
    // (레이어드)팝업창 연습 

    // (레이어드)팝업창 연습: '현재시각 팝업창' 버튼 클릭시 시간 보여줌
    document.querySelector('#btn_time').onclick = function () {
      document.querySelector('#timePopSection > h3').innerHTML = new Date().toLocaleTimeString();
      const timeSection = document.querySelector('#timePopSection');
      timeSection.style.display = 'block';
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
      timeSection.style.left = `${(vw-300)/2}px`;
      timeSection.style.top = `${(vh-200)/2}px`;
      console.log("timeSection.style.left: ", timeSection.style.left)
      console.log("timeSection.style.top: ", timeSection.style.top)
    }
    // '현재시각 팝업창' 안의 닫기 버튼
    document.querySelector('#btn_closeTime').onclick = function () {
      document.querySelector('#timePopSection').style.display = 'none';
    }


    // html element의 속성 접근하고 속성 값 변경하기
    // 상단 이미지 클릭시 이미지 소스 알림.
    document.querySelector('#cup').onclick = displaySrc;

    function displaySrc() {
      console.log('이미지 소스: ' + document.querySelector('#cup').getAttribute('src'));
      document.getElementById('cup').onclick = event => alert(
        `event type: ${event.type}, event location: ${event.pageX}, ${event.pageY}, screenXY: ${screenX}, ${screenY} scrollXY: ${scrollX}, ${scrollY}`
      )
    }

    // 하단 이미지 마우스 포인터 위치시 상단 영역의 이미지 바꾸기
    document.querySelectorAll('#small-pic img').forEach(item => {
      item.addEventListener('mouseover', function () {
        document.querySelector('#cup').setAttribute('src', this.src);
      }); // 포인터를 올리면 change Picture
      item.addEventListener('mouseout', () => document.querySelector('#cup').setAttribute('src',
        'images/coffee-pink.jpg'));
    });

    // 이미지 라이트 박스 - 썸네일 클릭시 레이어드 전체 팝업에 큰 이미지의 본 파일 보여주기
    // 작은 사이즈의 thumbnail 이미진 src 속성 이용, 큰 사이즈 경로는 data-src 속성 이용해 이미지 보여주는 방식
    const pics = document.getElementsByClassName('pic');
    for (let i = 0; i < pics.length; i++) {
      pics[i].addEventListener('click', function () {
        document.querySelector('#lightbox').style.display = 'block';
        document.querySelector('#lightbox img').src = this.getAttribute('data-src');
      });
    }
    // 라이트 박스 클릭시, 라이트박스 닫기
    document.getElementById('lightbox').onclick = function () {
      this.style.display = 'none';
    }

    // DOM에 노드 추가,삭제 하기
    // 노드 생성, 추가
    document.querySelector('#btn_newNode').onclick = function () {
      addNewNode();
      this.onclick = '';
      // 링크를 클릭하면 addNewNode() 가 한번만 실행되도록 하기 위한 것.
    }

    function addNewNode() {
      const newP = document.createElement('p');
      const txtNode = document.createTextNode('DOM은 document object model 의 약자임. ');
      newP.appendChild(txtNode)
      document.getElementById('section_imgChange').appendChild(newP)

      // 속성 값이 있는 노드 생성/추가 방법
      const newImg = document.createElement('img')
      const srcNode = document.createAttribute('src')
      const altNode = document.createAttribute('alt')
      srcNode.value = 'images/tree-3-thumb.jpg';
      altNode.value = '어두운 배경 나무 이미지';
      newImg.setAttributeNode(srcNode)
      newImg.setAttributeNode(altNode)
      document.getElementById('section_imgChange').appendChild(newImg);
    }


    // Todo 만들기
    document.getElementById('btn_addTodo').onclick = function (e) {
      let newItem = document.createElement('li');

      const idAttr = document.createAttribute('id');
      idAttr.value = 'item' + new Date().getTime().toString();
      newItem.setAttributeNode(idAttr);

      newItem.appendChild(createCheckBtn());
      newItem.appendChild(createEditTextBox());
      newItem.appendChild(createEditBtn());
      newItem.appendChild(createDelBtn());

      const itemList = document.querySelector('#todoList');
      // itemList.appendChild(newItem); // 맨 뒤에 추가
      // 최근 입력한 값을 맨 위에 나타나게/추가 하기
      // itemList.childNodes : itemList의 자식 노드들
      itemList.insertBefore(newItem, itemList.childNodes[0]);
      document.getElementById('input_todoText').value = '';
      /* return false; 하는 이유:
        <form> 태그 안에서 button의 기본기능인 submit을 먼저 실행하지 않고, 함수만 실행하게 하기 위해서.
        form 태그로 감싸지 않았다면 return false; 할 필요 없음.
        form 태그로 감쌓을때의 이점은 엔터키 눌러도 자동으로 click 이벤트 핸들러 호출함.
      */
      return false;
    }
    // 17장 마무리 문제 1번 풀기
    // 할일 목록과 완료/수정/지우기 기능 만들기
    function createCheckBtn() {
      const checkBtn = document.createElement('span')
      checkBtn.classList.add('check');
      checkBtn.innerHTML = '&#x2705;'; // '&check;' 
      checkBtn.onclick = function () {
        this.parentNode.classList.toggle('checked')
        this.parentNode.childNodes[1].classList.toggle('checked')
      }
      return checkBtn;
    }

    function createEditTextBox() {
      const inputText = document.createElement('input')
      let subject = document.getElementById('input_todoText');
      inputText.value = subject.value;
      inputText.readOnly = true;
      inputText.disabled = true;
      return inputText;
    }

    const EDIT_READONLY_MODE = 0;
    const EDIT_POSSIBLE_MODE = 1;
    const EDIT_READONLY_ICON = '\u270F'
    const EDIT_POSSIBLE_ICON = '\u2714'
    let currentEditMode = EDIT_READONLY_MODE;

    function createEditBtn() {
      const btnItem = document.createElement('button');
      // EDIT_READONLY_MODE
      btnItem.appendChild(document.createTextNode('\u270F')); //1f527 wrench
      btnItem.classList.add('btn')
      btnItem.onclick = function () {
        // changeEditBtnIcon()
        if (currentEditMode == EDIT_READONLY_MODE) {
          this.parentNode.childNodes[1].disabled = false;
          this.parentNode.childNodes[1].readOnly = false;
          this.parentNode.childNodes[1].select();
          this.parentNode.childNodes[2].replaceChild(document.createTextNode(EDIT_POSSIBLE_ICON), this.parentNode
            .childNodes[2]
            .firstChild)
          currentEditMode = EDIT_POSSIBLE_MODE;
        } else { // EDIT_POSSIBLE_MODE
          this.parentNode.childNodes[1].disabled = true;
          this.parentNode.childNodes[1].readOnly = true;
          this.parentNode.childNodes[2].replaceChild(document.createTextNode(EDIT_READONLY_ICON), this.parentNode
            .childNodes[2]
            .firstChild)
          currentEditMode = EDIT_READONLY_MODE;
        }
      }
      return btnItem;
    }

    function createDelBtn() {
      const btnItem = document.createElement("button");
      btnItem.appendChild(document.createTextNode('\u274c'));
      const clsAttr = document.createAttribute('class');
      clsAttr.value = 'btn'
      btnItem.setAttributeNode(clsAttr);
      btnItem.addEventListener('click', function () {
        this.parentNode.parentNode.removeChild(this.parentNode);
      });
      return btnItem;
    }

    // 17장 마무리 문제 2번 풀기
    // 동적으로 표 만들기
    function makeTable() {
      const table = document.createElement('table');
      const rows = document.querySelector('#rows');
      const cols = document.querySelector('#cols');
      let tr = undefined;
      let td = undefined;

      for (let rowNum = 0; rowNum < rows.value; rowNum++) {
        tr = document.createElement('tr');
        for (let colNum = 0; colNum < cols.value; colNum++) {
          td = document.createElement('td');
          td.append(document.createTextNode(`${rowNum}, ${colNum}`));
          tr.append(td)
        }
        table.append(tr)
      }
      document.getElementById('section_makeTable').appendChild(table);
    }
    document.querySelector('#btn_makeTable').addEventListener('click', makeTable);
  </script>

</body>

</html>